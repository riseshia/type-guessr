#!/usr/bin/env ruby
# frozen_string_literal: true

# TypeGuessr Self-Coverage Report
#
# Measures type inference success rate on the project's own codebase
#
# Usage:
#   bin/coverage [options]
#
# Options:
#   --path=PATH                 Project directory to analyze (default: current)
#   --report                    Generate markdown report to docs/coverage-report.md
#   --json                      Output in JSON format
#   --dump-untyped[=TYPES]      Dump untyped nodes to tmp/untyped_nodes.json
#                               Optionally filter by node types (comma-separated)
#   --limit=N                   Limit number of dumped untyped nodes
#
# Examples:
#   bin/coverage                              # Analyze current project
#   bin/coverage --path=/path/to/proj         # Analyze another project
#   bin/coverage --report                     # Generate markdown report
#   bin/coverage --json                       # Output JSON for scripts
#   bin/coverage --dump-untyped               # Dump all untyped nodes
#   bin/coverage --dump-untyped=ParamNode     # Dump only ParamNode
#   bin/coverage --dump-untyped --limit=100   # Limit to 100 nodes

require "bundler/setup"
require "prism"
require "optparse"
require "fileutils"
require "json"
require "ruby_indexer/ruby_indexer"

# Load TypeGuessr core components
require_relative "../lib/type_guessr/core/ir/nodes"
require_relative "../lib/type_guessr/core/types"
require_relative "../lib/type_guessr/core/converter/prism_converter"
require_relative "../lib/type_guessr/core/index/location_index"
require_relative "../lib/type_guessr/core/inference/resolver"
require_relative "../lib/type_guessr/core/registry/method_registry"
require_relative "../lib/type_guessr/core/registry/signature_registry"
require_relative "../lib/type_guessr/core/registry/instance_variable_registry"
require_relative "../lib/type_guessr/core/registry/class_variable_registry"
require_relative "../lib/type_guessr/core/type_simplifier"
require_relative "lib/tool_setup"
require_relative "lib/coverage_report"

module CoverageRunner
  # Runs coverage analysis on a codebase
  class Runner
    def initialize(path:, report:, json:, dump_untyped:, limit:)
      @path = path
      @report = report
      @json = json
      @dump_untyped = dump_untyped
      @limit = limit
    end

    def run
      log "=== TypeGuessr Self-Coverage Report ==="
      log
      log "Project path: #{@path || Dir.pwd}"

      files = ToolSetup.collect_indexable_files(path: @path)
      log "Found #{files.size} indexable files"
      log

      log "Building RubyIndexer for code_index..."
      code_index = ToolSetup.build_code_index(files)
      log "code_index ready."
      log

      log "Indexing files..."
      infra, location_index = build_index(files, code_index)
      log "Indexing complete."
      log

      report = CoverageRunner::CoverageReport.new(location_index, infra.resolver, infra.method_registry)
      result = report.generate

      if @json
        output_json(result, files.size)
      else
        output_text(result, files.size)
      end

      generate_markdown_report(result, files) if @report
      dump_untyped_nodes(report) if @dump_untyped
    end

    private def log(message = "")
      puts message unless @json
    end

    private def build_index(files, code_index)
      infra = ToolSetup.build_infrastructure(code_index)
      converter = TypeGuessr::Core::Converter::PrismConverter.new
      location_index = TypeGuessr::Core::Index::LocationIndex.new

      files.each do |file_path|
        source = File.read(file_path)
        parsed = Prism.parse(source)
        next unless parsed.value

        location_index.remove_file(file_path)

        context = ToolSetup.build_context(infra, file_path: file_path, location_index: location_index)

        parsed.value.statements&.body&.each do |stmt|
          converter.convert(stmt, context)
        end
      rescue StandardError => e
        log "Error indexing #{file_path}: #{e.message}"
      end

      location_index.finalize!
      [infra, location_index]
    end

    private def output_text(result, file_count)
      nc = result[:node_coverage]
      ss = result[:signature_score]

      puts "Node Coverage:      #{nc[:percentage]}% (#{nc[:typed]}/#{nc[:total]} nodes typed)"
      puts "Inference Coverage: #{nc[:inferred_percentage]}% (#{nc[:inferred_typed]}/#{nc[:inferred_total]} excluding trivial nodes)"
      puts

      # Sort breakdown by total count descending
      sorted_breakdown = nc[:breakdown].sort_by { |_, v| -v[:total] }
      sorted_breakdown.each do |node_type, stats|
        puts format(
          "  - %<type>-25s %<pct>6.1f%% (%<typed>d/%<total>d)",
          type: "#{node_type}:",
          pct: stats[:percentage],
          typed: stats[:typed],
          total: stats[:total]
        )
      end

      puts
      puts "Signature Score: #{format("%.2f", ss[:average_score])} (#{ss[:method_count]} project methods)"
      puts
      puts "Files analyzed: #{file_count}"
    end

    private def output_json(result, file_count)
      output = {
        node_coverage: result[:node_coverage],
        signature_score: result[:signature_score],
        files_analyzed: file_count
      }
      puts JSON.pretty_generate(output)
    end

    private def generate_markdown_report(result, files)
      log "\n=== Generating Coverage Report ==="

      FileUtils.mkdir_p("docs")
      report_path = "docs/coverage-report.md"
      File.write(report_path, build_markdown_content(result, files))
      log "Report saved to: #{report_path}"
    end

    private def build_markdown_content(result, files)
      nc = result[:node_coverage]
      ss = result[:signature_score]

      sorted_breakdown = nc[:breakdown].sort_by { |_, v| -v[:total] }
      breakdown_rows = sorted_breakdown.map do |node_type, stats|
        "| #{node_type} | #{stats[:percentage]}% | #{stats[:typed]}/#{stats[:total]} |"
      end.join("\n")

      <<~MARKDOWN
        # TypeGuessr Coverage Report

        Generated: #{Time.now.strftime("%Y-%m-%d %H:%M:%S")}

        ## Summary

        | Metric | Value |
        |--------|-------|
        | Files Analyzed | #{files.size} |
        | Node Coverage | #{nc[:percentage]}% (#{nc[:typed]}/#{nc[:total]}) |
        | Inference Coverage | #{nc[:inferred_percentage]}% (#{nc[:inferred_typed]}/#{nc[:inferred_total]}) |
        | Signature Score | #{format("%.2f", ss[:average_score])} |
        | Project Methods | #{ss[:method_count]} |

        > **Node Coverage** includes trivially-typed nodes (LiteralNode, SelfNode).
        > **Inference Coverage** excludes them to reflect actual type inference capability.

        ## Node Coverage Breakdown

        | Node Type | Coverage | Typed/Total |
        |-----------|----------|-------------|
        #{breakdown_rows}

        ## Metrics Explanation

        ### Node Coverage
        Percentage of IR nodes with successfully inferred types. DefNode is excluded to avoid double-counting (its params and return are counted separately).

        ### Signature Score
        Average of (typed_slots / total_slots) for each project method. Slots include all parameters plus the return type. A score of 1.0 means all method signatures are fully typed.

        ---

        ## How to Use

        ```bash
        # Run coverage report
        bin/coverage

        # Generate markdown report
        bin/coverage --report

        # Output as JSON
        bin/coverage --json

        # Analyze a different project
        bin/coverage --path=/path/to/project
        ```
      MARKDOWN
    end

    private def dump_untyped_nodes(report)
      log "\n=== Dumping Untyped Nodes ==="

      FileUtils.mkdir_p("tmp")

      # Extract filter from dump_untyped option (it can be true or a string)
      filter = @dump_untyped.is_a?(String) ? @dump_untyped : nil

      nodes = report.collect_untyped_nodes(filter: filter, limit: @limit)
      total_untyped = report.total_untyped_count

      output = {
        generated_at: Time.now.iso8601,
        total_untyped: total_untyped,
        dumped: nodes.size,
        filter: filter,
        nodes: nodes
      }

      output_path = "tmp/untyped_nodes.json"
      File.write(output_path, JSON.pretty_generate(output))
      log "Dumped #{nodes.size} untyped nodes to #{output_path}"
      log "Total untyped nodes: #{total_untyped}"
    end
  end
end

# Parse command line options
options = {
  path: nil,
  report: false,
  json: false,
  dump_untyped: false,
  limit: nil
}

OptionParser.new do |opts|
  opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

  opts.on("--path=PATH", "Project directory to analyze") do |v|
    options[:path] = File.expand_path(v)
  end

  opts.on("--report", "Generate markdown report") do
    options[:report] = true
  end

  opts.on("--json", "Output in JSON format") do
    options[:json] = true
  end

  opts.on("--dump-untyped[=TYPES]", "Dump untyped nodes to tmp/untyped_nodes.json") do |v|
    options[:dump_untyped] = v || true
  end

  opts.on("--limit=N", Integer, "Limit number of dumped nodes") do |v|
    options[:limit] = v
  end

  opts.on("-h", "--help", "Show this help") do
    puts opts
    exit
  end
end.parse!

runner = CoverageRunner::Runner.new(
  path: options[:path],
  report: options[:report],
  json: options[:json],
  dump_untyped: options[:dump_untyped],
  limit: options[:limit]
)

runner.run
