#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "lib/entry"
require_relative "lib/parser"
require_relative "lib/session_reader"

# Knowledge Manager CLI
# Manages the Knowledge Base section in CLAUDE.md
module KnowledgeManager
  class CLI
    attr_reader :project_path, :claude_md_path

    def initialize(project_path: nil)
      @project_path = project_path || Dir.pwd
      @claude_md_path = File.join(@project_path, "CLAUDE.md")
    end

    def run(args)
      # Extract --project-path if provided
      if (idx = args.index("--project-path"))
        @project_path = args[idx + 1]
        @claude_md_path = File.join(@project_path, "CLAUDE.md")
        args.delete_at(idx + 1)
        args.delete_at(idx)
      end
      command = args.shift
      case command
      when "read-session"
        read_session
      when "list"
        list_entries
      when "add"
        add_entry(args)
      when "helpful"
        update_score(args.first, :helpful)
      when "harmful"
        update_score(args.first, :harmful)
      when "cleanup"
        cleanup_entries
      else
        usage
      end
    end

    private

    def read_session
      session_path = SessionReader.find_latest_session(SessionReader::CLAUDE_DIR, project_path)
      if session_path.nil?
        warn "No session found for current project"
        exit 1
      end

      messages = SessionReader.read_messages(session_path)
      puts SessionReader.format_for_display(messages)
    end

    def list_entries
      content = read_claude_md
      entries = Parser.parse(content)

      if entries.empty?
        puts "No knowledge entries found."
        return
      end

      entries.each do |entry|
        puts entry.to_markdown
      end
    end

    def add_entry(args)
      # Parse multiple -c/-t pairs
      entries_to_add = []
      current_category = nil

      args.each_with_index do |arg, i|
        case arg
        when "--category", "-c"
          current_category = args[i + 1]
        when "--content", "-t"
          content = args[i + 1]
          entries_to_add << { category: current_category, content: content } if current_category && content && !content.empty?
        end
      end

      if entries_to_add.empty?
        warn "No valid entries. Use: -c CATEGORY -t \"content\" [-c CATEGORY -t \"content\" ...]"
        warn "Categories: #{Entry::CATEGORIES.join(", ")}"
        exit 1
      end

      # Validate all categories
      entries_to_add.each do |entry_data|
        unless Entry::CATEGORIES.include?(entry_data[:category])
          warn "Invalid category: #{entry_data[:category]}. Use: #{Entry::CATEGORIES.join(", ")}"
          exit 1
        end
      end

      claude_md = read_claude_md
      existing = Parser.parse(claude_md)
      added_entries = []

      entries_to_add.each do |entry_data|
        new_id = Entry.next_id(entry_data[:category], existing)
        new_entry = Entry.new(id: new_id, category: entry_data[:category], content: entry_data[:content])
        existing << new_entry
        added_entries << new_entry
      end

      # Trim to max 200 entries
      trimmed = Entry.trim_to_limit(existing)
      removed_count = existing.size - trimmed.size

      updated = Parser.update_content(claude_md, trimmed)
      write_claude_md(updated)

      added_entries.each do |entry|
        puts "Added: #{entry.to_markdown}"
      end

      puts "Trimmed #{removed_count} entries (limit: 200)" if removed_count.positive?
    end

    def update_score(entry_id, score_type)
      unless entry_id
        warn "Entry ID required"
        exit 1
      end

      claude_md = read_claude_md
      entries = Parser.parse(claude_md)
      entry = entries.find { |e| e.id == entry_id }

      unless entry
        warn "Entry not found: #{entry_id}"
        exit 1
      end

      case score_type
      when :helpful
        entry.helpful += 1
      when :harmful
        entry.harmful += 1
      end
      entry.last_ref_date = Date.today.to_s

      updated = Parser.update_content(claude_md, entries)
      write_claude_md(updated)

      puts "Updated: #{entry.to_markdown}"
    end

    def cleanup_entries
      claude_md = read_claude_md
      entries = Parser.parse(claude_md)

      removed = entries.select { |e| e.too_harmful? || e.stale? }
      kept = entries.reject { |e| e.too_harmful? || e.stale? }

      if removed.empty?
        puts "No entries to clean up."
        return
      end

      updated = Parser.update_content(claude_md, kept)
      write_claude_md(updated)

      puts "Removed #{removed.size} entries:"
      removed.each { |e| puts "  - #{e.id}: #{e.content}" }
    end

    def usage
      puts <<~USAGE
        Usage: knowledge-manager [--project-path PATH] <command> [options]

        Global Options:
          --project-path PATH       Path to project root (default: current directory)

        Commands:
          read-session              Read current session conversation
          list                      List all knowledge entries
          add -c CAT -t TEXT [...]   Add entries (multiple -c/-t pairs allowed)
          helpful ENTRY_ID          Mark entry as helpful (+1)
          harmful ENTRY_ID          Mark entry as harmful (+1)
          cleanup                   Remove stale/harmful entries

        Categories: #{Entry::CATEGORIES.join(", ")}
      USAGE
    end

    def read_claude_md
      unless File.exist?(claude_md_path)
        warn "CLAUDE.md not found at #{claude_md_path}"
        exit 1
      end
      File.read(claude_md_path)
    end

    def write_claude_md(content)
      File.write(claude_md_path, content)
    end
  end
end

KnowledgeManager::CLI.new.run(ARGV) if __FILE__ == $PROGRAM_NAME
